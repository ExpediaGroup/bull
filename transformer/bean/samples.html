<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from docs/site/markdown/transformer/bean/samples.md at $dateFormat.format( $currentDate )
 | Rendered using Apache Maven Fluido Skin 1.8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>Samples â€“ BULL - Bean Utils Light Library</title>
    <link rel="stylesheet" href="../../css/apache-maven-fluido-1.8.min.css" />
    <link rel="stylesheet" href="../../css/site.css" />
    <link rel="stylesheet" href="../../css/print.css" media="print" />
    <script src="../../js/apache-maven-fluido-1.8.min.js"></script>
<link rel="apple-touch-icon" sizes="180x180" href="images/icon/apple-touch-icon.png">
                <link rel="icon" type="image/png" sizes="32x32" href="images/icon/favicon-32x32.png">
                <link rel="icon" type="image/png" sizes="16x16" href="images/icon/favicon-16x16.png">
                <link rel="manifest" href="images/icon/site.webmanifest">
                <link rel="mask-icon" href="images/icon/safari-pinned-tab.svg" color="#5bbad5">
                <meta name="msapplication-TileColor" content="#ffffff">
                <meta name="theme-color" content="#ffffff">
  </head>
  <body class="topBarDisabled">
    <a href="https://github.com/ExpediaGroup/bull">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
        alt="Fork me on GitHub">
    </a>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left">            <h1>BULL - Bean Utils Light Library
</h1></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
      <li class=""><a href="../../../" title="Home">Home</a><span class="divider">/</span></li>
      <li class=""><a href="../.././" title="Bean Utils Light Library">Bean Utils Light Library</a><span class="divider">/</span></li>
    <li class="active ">Samples</li>
        <li id="publishDate" class="pull-right"><span class="divider">|</span> $i18n.getString( "site-renderer", $locale, "template.lastpublished" ): $dateValue</li>
          <li id="projectVersion" class="pull-right">$i18n.getString( "site-renderer", $locale, "template.version" ): 3.0.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Project info</li>
    <li><a href="../../glossary.html" title="Glossary"><span class="none"></span>Glossary</a></li>
    <li><a href="../../kotlin.html" title="Use it in Kotlin"><span class="none"></span>Use it in Kotlin</a></li>
   <li class="nav-header">Transformer</li>
    <li><a href="../../transformer/beanTransformer.html" title="Bean Transformer"><span class="icon-chevron-down"></span>Bean Transformer</a>
     <ul class="nav nav-list">
      <li class="active"><a href="#"><span class="none"></span>Samples</a></li>
      <li><a href="../../transformer/bean/performance.html" title="Performances"><span class="none"></span>Performances</a></li>
      <li><a href="../../transformer/bean/thirdPartyLibComparison.html" title="Third Party Lib Comparison"><span class="none"></span>Third Party Lib Comparison</a></li>
      <li><a href="../../transformer/bean/testing.html" title="How to test"><span class="none"></span>How to test</a></li>
     </ul></li>
    <li><a href="../../transformer/mapTransformer.html" title="Map Transformer"><span class="icon-chevron-right"></span>Map Transformer</a></li>
   <li class="nav-header">Bean Validation</li>
    <li><a href="../../validator/samples.html" title="Samples"><span class="none"></span>Samples</a></li>
   <li class="nav-header">Primitive type conversion</li>
    <li><a href="../../converter/samples.html" title="Samples"><span class="none"></span>Samples</a></li>
   <li class="nav-header">Quality check</li>
    <li><a href="https://coveralls.io/github/ExpediaGroup/bull" class="externalLink" title="Coveralls"><span class="none"></span>Coveralls</a></li>
   <li class="nav-header">Related Articles</li>
    <li><a href="https://dzone.com/articles/how-to-transform-any-type-of-java-bean-with-one-li" class="externalLink" title="DZone"><span class="none"></span>DZone</a></li>
    <li><a href="../../articles.html" title="InfoQ"><span class="icon-chevron-right"></span>InfoQ</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="$i18n.getString( "site-renderer", $locale, "template.builtby" ) Maven" class="poweredBy"><img class="builtBy" alt="$i18n.getString( "site-renderer", $locale, "template.builtby" ) Maven" src="../../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >

<section><a id="Bean_Transformation_samples"></a>
<h1>Bean Transformation samples</h1><section><section><a id="Simple_case.3A"></a>
<h3>Simple case:</h3>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {
    private final String name;                                  @NotNull
    private final BigInteger id;                                public BigInteger id;
    private final List&lt;FromSubBean&gt; subBeanList;                private final String name;
    private List&lt;String&gt; list;                                  private final List&lt;String&gt; list;
    private final FromSubBean subObject;                        private final List&lt;ToSubBean&gt; subBeanList;
    private ImmutableToSubFoo subObject;

    // all constructors                                         // all args constructor
    // getters and setters...                                   // getters and setters... 
}    
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer().transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Different_field_names_copy.3A"></a>
<h3>Different field names copy:</h3>
<p>From class and To class with different field names:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {

    private final String name;                                  private final String differentName;
    private final int id;                                       private final int id;
    private final List&lt;FromSubBean&gt; subBeanList;                private final List&lt;ToSubBean&gt; subBeanList;
    private final List&lt;String&gt; list;                            private final List&lt;String&gt; list;
    private final FromSubBean subObject;                        private final ToSubBean subObject;

    // getters...
    public ToBean(final String differentName,
                  final int id,
}                                                                       final List&lt;ToSubBean&gt; subBeanList,
    final List&lt;String&gt; list,
    final ToSubBean subObject) {
        this.differentName = differentName;
        this.id = id;
        this.subBeanList = subBeanList;
        this.list = list;
        this.subObject = subObject;
    }

    // getters...           

}
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">beanUtils.getTransformer().withFieldMapping(new FieldMapping&lt;&gt;(&quot;name&quot;, &quot;differentName&quot;)).transform(fromBean, ToBean.class);                                                               
</code></pre>
<p>it is also possible to map a field in the source class into multiple fields in the destination object.</p>
<p>Given the following source class:</p>

<pre><code class="nohighlight nocode">public class SourceClass {
    private final String name;
    private final int id;
}
</code></pre>
<p>the following destination class:</p>

<pre><code class="nohighlight nocode">public class DestinationClass {
    private final String name;
    private final int id;
    private final int index;
}
</code></pre>
<p>and the following operations:</p>

<pre><code class="nohighlight nocode">var sourceObj = new SourceClass(&quot;foo&quot;, 123);

var multipleFieldMapping = new FieldMapping&lt;&gt;(&quot;id&quot;, &quot;index&quot;, &quot;identifier&quot;);

var destObj = new BeanUtils().getBeanTransformer()
                     .withFieldMapping(multipleFieldMapping)
                     .transform(sourceObj, DestinationClass.class);

System.out.println(&quot;name = &quot; + destObj.getName());
System.out.println(&quot;id = &quot; + destObj.getId());
System.out.println(&quot;index = &quot; + destObj.getIndex());
</code></pre>
<p>the output will be:</p>

<pre><code class="nohighlight nocode">name = foo
id = 123
index = 123
</code></pre></section><section><a id="Mapping_destination_fields_with_correspondent_fields_contained_inside_one_of_the_nested_objects_in_the_source_object.3A"></a>
<h3>Mapping destination fields with correspondent fields contained inside one of the nested objects in the source object:</h3>
<p>Assuming that the object <code>FromSubBean</code> is declared as follow:</p>

<pre><code class="language-java">public class FromSubBean {

    private String serialNumber;
    private Date creationDate;

    // getters and setters... 

}
</code></pre>
<p>and our source object and destination object are described as follow:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {

    private final int id;                                       private final int id;
    private final String name;                                  private final String name;
    private final FromSubBean subObject;                        private final String serialNumber;
    private final Date creationDate;

    // all args constructor                                     // all args constructor
    // getters...                                               // getters... 

}                                                           }
</code></pre>
<p>the fields: <code>serialNumber</code> and <code>creationDate</code> needs to be retrieved from <code>subObject</code>, this can be done by defining the whole path to the end property:</p>

<pre><code class="language-java">FieldMapping serialNumberMapping = new FieldMapping&lt;&gt;(&quot;subObject.serialNumber&quot;, &quot;serialNumber&quot;);                                                             
FieldMapping creationDateMapping = new FieldMapping&lt;&gt;(&quot;subObject.creationDate&quot;, &quot;creationDate&quot;);
                                                             
beanUtils.getTransformer()
         .withFieldMapping(serialNumberMapping, creationDateMapping)
         .transform(fromBean, ToBean.class);                                                               
</code></pre></section><section><a id="Different_field_names_defining_constructor_args.3A"></a>
<h3>Different field names defining constructor args:</h3>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private final String differentName;                   
   private final int id;                                       private final int id;                      
   private final List&lt;FromSubBean&gt; subBeanList;                private final List&lt;ToSubBean&gt; subBeanList;                 
   private final List&lt;String&gt; list;                            private final List&lt;String&gt; list;                    
   private final FromSubBean subObject;                        private final ToSubBean subObject;                    
   
   // all args constructor
   // getters...
                                                               public ToBean(@ConstructorArg(&quot;name&quot;) final String differentName, 
                                                                        @ConstructorArg(&quot;id&quot;) final int id,
}                                                                       @ConstructorArg(&quot;subBeanList&quot;) final List&lt;ToSubBean&gt; subBeanList,
                                                                        @ConstructorArg(fieldName =&quot;list&quot;) final List&lt;String&gt; list,
                                                                        @ConstructorArg(&quot;subObject&quot;) final ToSubBean subObject) {
                                                                        this.differentName = differentName;
                                                                        this.id = id;
                                                                        this.subBeanList = subBeanList;
                                                                        this.list = list;
                                                                        this.subObject = subObject; 
                                                                    }
                                                                
                                                                    // getters...           
                                              
                                                            }
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer().transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Different_field_names_and_types_applying_transformation_through_lambda_function.3A"></a>
<h3>Different field names and types applying transformation through lambda function:</h3>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  @NotNull                   
   private final BigInteger id;                                public BigInteger identifier;                      
   private final List&lt;FromSubBean&gt; subBeanList;                private final String name;                 
   private List&lt;String&gt; list;                                  private final List&lt;String&gt; list;                    
   private final FromSubBean subObject;                        private final List&lt;ImmutableToSubFoo&gt; nestedObjectList;                    
   private final String locale;                                private final Locale locale;                    
                                                               private ImmutableToSubFoo nestedObject;
       
   // constructors...                                          // constructors...
   // getters and setters...                                   // getters and setters...
                                                                                                                              
}                                                           }
</code></pre>

<pre><code class="language-java">FieldTransformer&lt;BigInteger, BigInteger&gt; fieldTransformer = new FieldTransformer&lt;&gt;(&quot;identifier&quot;, BigInteger::negate);
FieldTransformer&lt;String, Locale&gt; localeTransformer = new FieldTransformer&lt;&gt;(&quot;locale&quot;, Locale::forLanguageTag);
beanUtils.getTransformer()
    .withFieldMapping(new FieldMapping&lt;&gt;(&quot;id&quot;, &quot;identifier&quot;))
    .withFieldTransformer(fieldTransformer).transform(fromBean, ToBean.class)
    .withFieldTransformer(localeTransformer);
</code></pre>
<p>It's also possible to apply the same transformation function on multiple fields. Taking as an example the above bean and
assuming that we would negate both the id and the identifier, the transformer function has to be defined as follows:</p>

<pre><code class="language-java">FieldTransformer&lt;BigInteger, BigInteger&gt; fieldTransformer = new FieldTransformer&lt;&gt;(List.of(&quot;identifier&quot;, &quot;index&quot;), BigInteger::negate);
</code></pre></section><section><a id="Assign_a_default_value_in_case_of_missing_field_in_the_source_object.3A"></a>
<h3>Assign a default value in case of missing field in the source object:</h3>
<p>Assign a default value in case of a missing field in the source object:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  @NotNull                   
   private final BigInteger id;                                public BigInteger id;                      
                                                               private final String name;                 
                                                               private String notExistingField; // this will be null and no exceptions will be raised

   // constructors...                                          // constructors...
   // getters...                                               // getters and setters...

}                                                           }
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer()
                    .setDefaultValueForMissingField(true).transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Disable_the_default_value_set_for_primitive_types_in_case_they_are_null.3A"></a>
<h3>Disable the default value set for primitive types in case they are null:</h3>
<p>BULL by default sets the default value for all primitive types fields in case their value is in the source object.
Given the following Java Bean:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  @NotNull                   
   private final BigInteger id;                                public BigInteger id;                      
                                                               private final String name;                 

   // constructors...                                          // constructors...
   // getters...                                               // getters and setters...

}                                                           }
</code></pre>
<p>in case the field <code>id</code> in the <code>FromBean</code> object is <code>null</code>, the value assigned the correspondent field in the <code>ToBean</code> object will be <code>0</code>.
To disable this you can simply do:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer()
                    .setDefaultValueForMissingPrimitiveField(false).transform(fromBean, ToBean.class);
</code></pre>
<p>in this case, the field <code>id</code> after the transformation will be <code>null</code></p></section><section><a id="Applying_a_transformation_function_in_case_of_missing_fields_in_the_source_object.3A"></a>
<h3>Applying a transformation function in case of missing fields in the source object:</h3>
<p>Assign a default value in case of a missing field in the source object:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  @NotNull                   
   private final BigInteger id;                                public BigInteger id;                      
                                                               private final String name;                 
                                                               private String notExistingField; // this will have value: sampleVal
                                                               
   // all args constructor                                     // constructors...
   // getters...                                               // getters and setters...
}                                                           }
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">FieldTransformer&lt;String, String&gt; notExistingFieldTransformer = new FieldTransformer&lt;&gt;(&quot;notExistingField&quot;, () -&gt; &quot;sampleVal&quot;);
ToBean toBean = beanUtils.getTransformer()
                    .withFieldTransformer(notExistingFieldTransformer)
                    .transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Apply_a_transformation_function_on_a_field_contained_in_a_nested_object.3A"></a>
<h3>Apply a transformation function on a field contained in a nested object:</h3>
<p>This example shows how a lambda transformation function can be applied to a nested object field.</p>
<p>Given:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private final String name;                   
   private final FromSubBean nestedObject;                     private final ToSubBean nestedObject;                    

   // all args constructor                                     // all args constructor
   // getters...                                               // getters...
}                                                           }
</code></pre>
<p>and</p>

<pre><code class="language-java">public class ToSubBean {                           
   private final String name;                   
   private final long index;                    
}
</code></pre>
<p>Assuming that the lambda transformation function should be applied only to field: <code>name</code> contained into the <code>ToSubBean</code> object, the transformation function has to be defined as
follow:</p>

<pre><code class="language-java">FieldTransformer&lt;String, String&gt; nameTransformer = new FieldTransformer&lt;&gt;(&quot;nestedObject.name&quot;, StringUtils::capitalize);
ToBean toBean = beanUtils.getTransformer()
                    .withFieldTransformer(nameTransformer)
                    .transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Map_a_primitive_type_field_in_the_source_object_into_a_nested_object.3A"></a>
<h3>Map a primitive type field in the source object into a nested object:</h3>
<p>This example shows how to map a primitive field into a nested object into the destination one.</p>
<p>Given:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private final String name;                   
   private final FromSubBean nestedObject;                     private final ToSubBean nestedObject;                    
   private final int x;
   // all args constructor                                     // all args constructor
   // getters...                                               // getters...
}                                                           }
</code></pre>
<p>and</p>

<pre><code class="language-java">public class ToSubBean {                           
   private final int x;
   
   // all args constructor
}  // getters...          
</code></pre>
<p>Assuming that the value <code>x</code> should be mapped into the field: <code>x</code> contained into the <code>ToSubBean</code> object, the field mapping has to be defined as
follow:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer()
                    .withFieldMapping(new FieldMapping&lt;&gt;(&quot;x&quot;, &quot;nestedObject.x&quot;));
</code></pre></section><section><a id="Apply_a_transformation_function_on_all_fields_matching_with_the_given_one.3A"></a>
<h3>Apply a transformation function on all fields matching with the given one:</h3>
<p>This example shows how a lambda transformation function can be applied to all fields matching with the given one independently from their position.</p>
<p>Given:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private final String name;                   
   private final FromSubBean nestedObject;                     private final ToSubBean nestedObject;                    

   // all args constructor                                     // all args constructor
   // getters...                                               // getters...
}                                                           }
</code></pre>
<p>and</p>

<pre><code class="language-java">public class FromSubBean {                                  public class ToSubBean {                           
   private final String name;                                  private final String name;                   
   private final long index;                                   private final long index;                    
   
   // all args constructor                                     // all args constructor
   // getters...                                               // getters...
}                                                           }
</code></pre>
<p>Assuming that the lambda transformation function should be applied only to the field: <code>name</code> contained in the <code>ToSubBean</code> object, the transformation function has to be defined
as
follow:</p>

<pre><code class="language-java">FieldTransformer&lt;String, String&gt; nameTransformer = new FieldTransformer&lt;&gt;(&quot;name&quot;, StringUtils::capitalize);
ToBean toBean = beanUtils.getTransformer()
                    .setFlatFieldNameTransformation(true)
                    .withFieldTransformer(nameTransformer)
                    .transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Static_transformer_function.3A"></a>
<h3>Static transformer function:</h3>

<pre><code class="language-java">List&lt;FromFooSimple&gt; fromFooSimpleList = Arrays.asList(fromFooSimple, fromFooSimple);
</code></pre>
<p>can be transformed as follow:</p>

<pre><code class="language-java">Function&lt;FromFooSimple, ImmutableToFooSimple&gt; transformerFunction = BeanUtils.getTransformer(ImmutableToFooSimple.class);
List&lt;ImmutableToFooSimple&gt; actual = fromFooSimpleList.stream()
                .map(transformerFunction)
                .collect(Collectors.toList());
</code></pre>
<p>or if you have a pre-configured transformer:</p>

<pre><code class="language-java">Function&lt;FromFooSimple, ImmutableToFooSimple&gt; transformerFunction = BeanUtils.getTransformer(&lt;yourPreconfiguredTransformer&gt;, ImmutableToFooSimple.class);
List&lt;ImmutableToFooSimple&gt; actual = fromFooSimpleList.stream()
                .map(transformerFunction)
                .collect(Collectors.toList());
</code></pre></section><section><a id="Enable_Java_Beans_validation.3A"></a>
<h3>Enable Java Beans validation:</h3>
<p>Assuming that the field: <code>id</code> in the fromBean instance is null.</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  @NotNull                   
   private final BigInteger id;                                public BigInteger id;                      
                                                               private final String name;

   // all args constructor                                     // all args constructor
   // getters...                                               // getters and setters...
}                                                            }
</code></pre>
<p>adding the following configuration an exception will be thrown:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer()
                     .setValidationEnabled(true)
                     .transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Copy_on_an_existing_instance.3A"></a>
<h3>Copy on an existing instance:</h3>
<p>Given:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private String name;                   
   private final FromSubBean nestedObject;                     private ToSubBean nestedObject;                    

   // all args constructor                                     // constructor
   // getters...                                               // getters and setters...
}                                                           }
</code></pre>
<p>if you need to perform the copy on an already existing object, just do:</p>

<pre><code class="language-java">ToBean toBean = new ToBean();
beanUtils.getTransformer().transform(fromBean, toBean);
</code></pre></section><section><a id="Skip_transformation_on_a_given_set_of_fields.3A"></a>
<h3>Skip transformation on a given set of fields:</h3>
<p>Given:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String name;                                  private String name;                   
   private final FromSubBean nestedObject;                     private ToSubBean nestedObject;                    

   // all args constructor                                     // constructor
   // getters...                                               // getters and setters...
}                                                           }

public class FromBean2 {                   
   private final int index;             
   private final FromSubBean nestedObject;
                                          
   // all args constructor                
   // getters...                          
}                                         
</code></pre>
<p>if you need to skip the transformation for a given field, just do:</p>

<pre><code class="language-java">ToBean toBean = new ToBean();
beanUtils.getTransformer()
    .skipTransformationForField(&quot;nestedObject&quot;)
    .transform(fromBean, toBean);
</code></pre>
<p>where <code>nestedObject</code> is the name of the field in the destination object.</p>
<p>This feature allows us to <strong>transform an object keeping the data from different sources</strong>.</p>
<p>To better explain this function let's assume that the <code>ToBean</code> (defined above) should be transformed as follow:</p>
<ul>

<li><code>name</code> field value has been taken from the <code>FromBean</code> object</li>
<li><code>nestedObject</code> field value has been taken from the <code>FromBean2</code> object</li>
</ul>
<p>the objective can be reached by doing:</p>

<pre><code class="language-java">// create the destination object
ToBean toBean = new ToBean();

// execute the first transformation skipping the copy of: 'nestedObject' field that should come from the other source object
beanUtils.getTransformer()
    .skipTransformationForField(&quot;nestedObject&quot;)
    .transform(fromBean, toBean);

// then execute the transformation skipping the copy of: 'name' field that should come from the other source object
beanUtils.getTransformer()
    .skipTransformationForField(&quot;name&quot;)
    .transform(fromBean2, toBean);
</code></pre></section><section><a id="Not_existing_field_in_the_source_object.3A"></a>
<h3>Not existing field in the source object:</h3>
<p>In case the destination class has a field that does not exist in the source object, but it contains a getter method returning the value, the library should gets the field value from that method.</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
                                                               private final BigInteger id;
    public BigInteger getId() {                                   
        return BigInteger.TEN;                                 // all args constructor
   }                                                           // getters...
}                                                               
                                                            }
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">ToBean toBean = beanUtils.getTransformer().transform(fromBean, ToBean.class);
</code></pre></section><section><a id="Transform_primitive_types_automatically"></a>
<h3>Transform primitive types automatically</h3>
<p>Given the following Java Bean:</p>

<pre><code class="language-java">public class FromBean {                                     public class ToBean {                           
   private final String indexNumber;                           private final int indexNumber;                                 
   private final BigInteger id;                                public Long id;                      

   // constructors...                                          // constructors...
   // getters...                                               // getters and setters...

}                                                           }
</code></pre>
<p>as, by default the primitive type conversion is disabled, to get the above object converted we should have
implemented transformer functions for both field <code>indexNumber</code> and <code>id</code>, but this can be done automatically by enabling the
the functionality described above.</p>

<pre><code class="language-java">Transformer transformer = beanUtils.getTransformer()
                             .setPrimitiveTypeConversionEnabled(true);

ToBean toBean = transformer.transform(fromBean, ToBean.class);
</code></pre>
<p><strong>IMPORTANT:</strong> The primitive type transformation (if enabled) is executed before any other <code>FieldTransformer</code> function is defined on a specific field.
This means that once the <code>FieldTransformer</code> function will be executed the field value has already been transformed.</p></section></section><section><a id="Transform_Java_Record"></a>
<h2>Transform Java Record</h2><section><a id="Simple_case.3A_1"></a>
<h3>Simple case:</h3>

<pre><code class="language-java">public record FromFooRecord(BigInteger id, String name) {    public record RecordToFoo(BigInteger id, String name) {                           
}                                                            }  
</code></pre>
<p>And one line code as:</p>

<pre><code class="language-java">var toBean = beanUtils.getTransformer().transform(fromBean, RecordToFoo.class);
</code></pre>
<p>More sample beans can be found in the test package: <code>com.expediagroup.beans.sample</code> or on
DZone: <a href="https://dzone.com/articles/how-to-transform-any-type-of-java-bean-with-one-li" class="externalLink">How to Transform Any Type of Java Bean With BULL</a></p></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &#169;      2019&#x2013;${currentYear}<a href="http://expediagroup.com">Expedia Group</a>.
.</p>
        </div>
      </div>
    </footer>
  </body>
</html>

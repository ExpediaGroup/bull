<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BULL - Common</a> &gt; <a href="index.source.html" class="el_package">com.hotels.transformer.utils</a> &gt; <span class="el_source">ClassUtils.java</span></div><h1>ClassUtils.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2019-2020 Expedia, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hotels.transformer.utils;

import static java.lang.invoke.LambdaMetafactory.metafactory;
import static java.lang.invoke.MethodHandles.lookup;
import static java.lang.invoke.MethodHandles.privateLookupIn;
import static java.lang.invoke.MethodType.methodType;
import static java.lang.reflect.Modifier.isFinal;
import static java.lang.reflect.Modifier.isPrivate;
import static java.lang.reflect.Modifier.isPublic;
import static java.lang.reflect.Modifier.isStatic;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;
import static java.util.Collections.max;
import static java.util.Comparator.comparing;
import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.Optional.ofNullable;
import static java.util.Set.of;
import static java.util.stream.Collectors.toList;

import static com.hotels.transformer.base.Defaults.defaultValue;
import static com.hotels.transformer.cache.CacheManagerFactory.getCacheManager;
import static com.hotels.transformer.constant.ClassType.IMMUTABLE;
import static com.hotels.transformer.constant.ClassType.MIXED;
import static com.hotels.transformer.constant.ClassType.MUTABLE;
import static com.hotels.transformer.constant.Filters.IS_FINAL_AND_NOT_STATIC_FIELD;
import static com.hotels.transformer.constant.Filters.IS_NOT_FINAL_AND_NOT_STATIC_FIELD;
import static com.hotels.transformer.constant.Filters.IS_NOT_FINAL_FIELD;
import static com.hotels.transformer.validator.Validator.notNull;

import java.lang.annotation.Annotation;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Currency;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.hotels.transformer.cache.CacheManager;
import com.hotels.transformer.constant.ClassType;
import com.hotels.transformer.error.InstanceCreationException;
import com.hotels.transformer.error.InvalidBeanException;
import com.hotels.transformer.error.MissingMethodException;

/**
 * Reflection utils for Class objects.
 */
public final class ClassUtils {
    /**
     * Default method name used by a Builder for creating an object.
     */
    public static final String BUILD_METHOD_NAME = &quot;build&quot;;

    /**
     * Class nullability error message constant.
     */
    private static final String CLAZZ_CANNOT_BE_NULL = &quot;clazz cannot be null!&quot;;

    /**
     * CacheManager class {@link CacheManager}.
     */
<span class="fc" id="L93">    private static final CacheManager CACHE_MANAGER = getCacheManager(&quot;classUtils&quot;);</span>

    /**
     * Primitive types list.
     */
<span class="fc" id="L98">    private static final Set&lt;Class&lt;?&gt;&gt; PRIMITIVE_TYPES = of(String.class, Boolean.class, Integer.class, Long.class,</span>
           Double.class, BigDecimal.class, BigInteger.class, Short.class, Float.class, Character.class, Byte.class, Void.class);

    /**
     * Method Handles lookup.
     */
<span class="fc" id="L104">    private static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP = lookup();</span>

    /**
     * Reflection utils instance {@link ReflectionUtils}.
     */
    private final ReflectionUtils reflectionUtils;

    /**
     * Default constructor.
     */
<span class="fc" id="L114">    public ClassUtils() {</span>
<span class="fc" id="L115">        this.reflectionUtils = new ReflectionUtils();</span>
<span class="fc" id="L116">    }</span>

    /**
     * Checks if an object is a primitive or special type.
     * @param clazz the class to check
     * @return true if is primitive or special type, false otherwise
     */
    public boolean isPrimitiveOrSpecialType(final Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (isNull(clazz)) {</span>
<span class="fc" id="L125">            return false;</span>
        }
<span class="fc" id="L127">        final String cacheKey = &quot;isPrimitiveOrSpecial-&quot; + clazz.getName();</span>
<span class="fc" id="L128">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc bfc" id="L129" title="All 4 branches covered.">            final Boolean res = isPrimitiveType(clazz) || isSpecialType(clazz);</span>
<span class="fc" id="L130">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L131">            return res;</span>
        });
    }

    /**
     * Checks if an object is a special type.
     * @param clazz the class to check
     * @return true if is special type, false otherwise
     */
    public boolean isPrimitiveType(final Class&lt;?&gt; clazz) {
<span class="fc" id="L141">        final String cacheKey = &quot;isPrimitive-&quot; + clazz.getName();</span>
<span class="fc" id="L142">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="pc bpc" id="L143" title="1 of 6 branches missed.">            final Boolean res = clazz.isPrimitive() || PRIMITIVE_TYPES.contains(clazz) || clazz.isEnum();</span>
<span class="fc" id="L144">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L145">            return res;</span>
        });
    }

    /**
     * Checks if an object is a primitive type array.
     * @param clazz the class to check
     * @return true if is primitive type array, false otherwise
     */
    public boolean isPrimitiveTypeArray(final Class&lt;?&gt; clazz) {
<span class="fc" id="L155">        final String cacheKey = &quot;isPrimitiveTypeArray-&quot; + clazz.getName();</span>
<span class="fc" id="L156">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">            final Boolean res = clazz.isArray() &amp;&amp; isPrimitiveType(clazz.getComponentType());</span>
<span class="fc" id="L158">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L159">            return res;</span>
        });
    }

    /**
     * Checks if an object is a special type.
     * The label &quot;Special classes&quot; refers to all objects that has to be copied without applying any special transformation.
     * @param clazz the class to check
     * @return true if is special type, false otherwise
     */
    public boolean isSpecialType(final Class&lt;?&gt; clazz) {
<span class="fc" id="L170">        final String cacheKey = &quot;isSpecial-&quot; + clazz.getName();</span>
<span class="fc" id="L171">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc bfc" id="L172" title="All 6 branches covered.">            final Boolean res = clazz.equals(Currency.class) || clazz.equals(Locale.class) || Temporal.class.isAssignableFrom(clazz)</span>
<span class="pc bpc" id="L173" title="1 of 6 branches missed.">                    || clazz.equals(Date.class) || clazz.equals(Properties.class) || clazz.isSynthetic();</span>
<span class="fc" id="L174">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L175">            return res;</span>
        });
    }

    /**
     * Checks if the given type is a {@link Double}.
     * @param type the class to check
     * @return true if is Double
     */
    public static boolean isDouble(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L185" title="All 4 branches covered.">        return Double.class.isAssignableFrom(type) || type == double.class;</span>
    }

    /**
     * Checks if the given type is a {@link Float}.
     * @param type the class to check
     * @return true if is Float
     */
    public static boolean isFloat(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L194" title="All 4 branches covered.">        return Float.class.isAssignableFrom(type) || type == float.class;</span>
    }

    /**
     * Checks if the given type is a {@link Long}.
     * @param type the class to check
     * @return true if is Long
     */
    public static boolean isLong(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L203" title="All 4 branches covered.">        return Long.class.isAssignableFrom(type) || type == long.class;</span>
    }

    /**
     * Checks if the given type is a {@link Short}.
     * @param type the class to check
     * @return true if is Short
     */
    public static boolean isShort(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L212" title="All 4 branches covered.">        return Short.class.isAssignableFrom(type) || type == short.class;</span>
    }

    /**
     * Checks if the given type is an {@link Integer}.
     * @param type the class to check
     * @return true if is Integer
     */
    public static boolean isInt(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L221" title="All 4 branches covered.">        return Integer.class.isAssignableFrom(type) || type == int.class;</span>
    }

    /**
     * Checks if the given type is a {@link Byte}.
     * @param type the class to check
     * @return true if is Byte
     */
    public static boolean isByte(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L230" title="All 4 branches covered.">        return Byte.class.isAssignableFrom(type) || type == byte.class;</span>
    }

    /**
     * Checks if the given type is a {@link Character}.
     * @param type the class to check
     * @return true if is Character
     */
    public static boolean isChar(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L239" title="All 4 branches covered.">        return Character.class.isAssignableFrom(type) || type == char.class;</span>
    }

    /**
     * Checks if the given type is a {@link Boolean}.
     * @param type the class to check
     * @return true if is Boolean
     */
    public static boolean isBoolean(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L248" title="All 4 branches covered.">        return Boolean.class.isAssignableFrom(type) || type == boolean.class;</span>
    }

    /**
     * Checks if the given type is a String.
     * @param type the class to check
     * @return true if is String
     */
    public static boolean isString(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        return type == String.class;</span>
    }

    /**
     * Checks if the given type is a {@link BigInteger}.
     * @param type the class to check
     * @return true if is String
     */
    public static boolean isBigInteger(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        return type == BigInteger.class;</span>
    }

    /**
     * Checks if the given type is a {@link BigDecimal}.
     * @param type the class to check
     * @return true if is String
     */
    public static boolean isBigDecimal(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        return type == BigDecimal.class;</span>
    }

    /**
     * Checks if the given type is a byte[].
     * @param type the class to check
     * @return true if is String
     */
    public static boolean isByteArray(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">        return type == byte[].class;</span>
    }

    /**
     * Return the private final fields of a class.
     * @param clazz class from which gets the field
     * @return a list of private final fields.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Field&gt; getPrivateFinalFields(final Class&lt;?&gt; clazz) {
<span class="fc" id="L294">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L295">        final String cacheKey = &quot;PrivateFinalFields-&quot; + clazz.getName();</span>
<span class="fc" id="L296">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L297">            final List&lt;Field&gt; res = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            if (hasSuperclass(clazz.getSuperclass())) {</span>
<span class="fc" id="L299">                res.addAll(getPrivateFinalFields(clazz.getSuperclass()));</span>
            }
<span class="fc" id="L301">            res.addAll(stream(getDeclaredFields(clazz))</span>
                    //.parallel()
<span class="fc" id="L303">                    .filter(IS_FINAL_AND_NOT_STATIC_FIELD)</span>
<span class="fc" id="L304">                    .collect(toList()));</span>
<span class="fc" id="L305">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L306">            return res;</span>
        });
    }

    /**
     * Checks if a class has a clazz different from {@link Object}.
     * @param clazz the class to check.
     * @return true if the given class extends another class different from object
     */
    private boolean hasSuperclass(final Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">        return nonNull(clazz) &amp;&amp; !clazz.equals(Object.class);</span>
    }

    /**
     * Return the total fields matching with the given predicate.
     * @param clazz class from which gets the field
     * @param predicate the condition that needs to match
     * @return the total matching item.
     */
    public int getTotalFields(final Class&lt;?&gt; clazz, final Predicate&lt;? super Field&gt; predicate) {
<span class="fc" id="L326">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L327">        final String cacheKey = &quot;TotalFields-&quot; + clazz.getName() + '-' + predicate;</span>
<span class="fc" id="L328">        return CACHE_MANAGER.getFromCache(cacheKey, Integer.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L329">            List&lt;Field&gt; declaredFields = getDeclaredFields(clazz, true);</span>
<span class="fc" id="L330">            int res = ofNullable(predicate)</span>
<span class="fc" id="L331">                    .map(filter -&gt; (int) declaredFields.stream().filter(filter).count())</span>
<span class="fc" id="L332">                    .orElseGet(declaredFields::size);</span>
<span class="fc" id="L333">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L334">            return res;</span>
        });
    }

    /**
     * Return the private fields of a class.
     * @param clazz class from which gets the field
     * @return a list of private final fields.
     */
    public List&lt;Field&gt; getPrivateFields(final Class&lt;?&gt; clazz) {
<span class="fc" id="L344">        return getPrivateFields(clazz, false);</span>
    }

    /**
     * Return the private fields of a class.
     * @param clazz class from which gets the field
     * @param skipFinal if true it skips the final fields otherwise all private fields are retrieved.
     * @return a list of private fields.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Field&gt; getPrivateFields(final Class&lt;?&gt; clazz, final boolean skipFinal) {
<span class="fc" id="L355">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L356">        final String cacheKey = &quot;PrivateFields-&quot; + clazz.getName() + &quot;-skipFinal-&quot; + skipFinal;</span>
<span class="fc" id="L357">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L358">            final List&lt;Field&gt; res = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            if (hasSuperclass(clazz.getSuperclass())) {</span>
<span class="fc" id="L360">                res.addAll(getPrivateFields(clazz.getSuperclass(), skipFinal));</span>
            }
<span class="fc" id="L362">            res.addAll(stream(getDeclaredFields(clazz))</span>
                    //.parallel()
<span class="fc bfc" id="L364" title="All 4 branches covered.">                    .filter(field -&gt; isPrivate(field.getModifiers())</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                            &amp;&amp; (!skipFinal || !isFinal(field.getModifiers()))</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                            &amp;&amp; !isStatic(field.getModifiers()))</span>
<span class="fc" id="L367">                    .collect(toList()));</span>
<span class="fc" id="L368">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L369">            return res;</span>
        });
    }

    /**
     * Return the fields of a class.
     * @param clazz class from which gets the field
     * @param skipStatic if true it skips the static fields otherwise all private fields are retrieved.
     * @return a list of class fields.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Field&gt; getDeclaredFields(final Class&lt;?&gt; clazz, final boolean skipStatic) {
<span class="fc" id="L381">        final String cacheKey = &quot;DeclaredFields-&quot; + clazz.getName() + &quot;-skipStatic-&quot; + skipStatic;</span>
<span class="fc" id="L382">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L383">            final List&lt;Field&gt; res = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (hasSuperclass(clazz.getSuperclass())) {</span>
<span class="fc" id="L385">                res.addAll(getDeclaredFields(clazz.getSuperclass(), skipStatic));</span>
            }
<span class="fc" id="L387">            stream(getDeclaredFields(clazz))</span>
<span class="fc bfc" id="L388" title="All 4 branches covered.">                    .filter(field -&gt; !skipStatic || !isStatic(field.getModifiers()))</span>
<span class="fc" id="L389">                    .forEach(field -&gt; {</span>
<span class="fc" id="L390">                        field.setAccessible(true);</span>
<span class="fc" id="L391">                        res.add(field);</span>
<span class="fc" id="L392">                    });</span>
<span class="fc" id="L393">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L394">            return res;</span>
        });
    }

    /**
     * Returns the class fields.
     * @param clazz the class from which gets the field.
     * @return a list of class fields
     */
    private Field[] getDeclaredFields(final Class&lt;?&gt; clazz) {
<span class="fc" id="L404">        final String cacheKey = &quot;ClassDeclaredFields-&quot; + clazz.getName();</span>
<span class="fc" id="L405">        return CACHE_MANAGER.getFromCache(cacheKey, Field[].class).orElseGet(() -&gt; {</span>
<span class="fc" id="L406">            Field[] res = clazz.getDeclaredFields();</span>
<span class="fc" id="L407">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L408">            return res;</span>
        });
    }

    /**
     * Returns the concrete class of a field.
     * @param field the field for which the concrete class has to be retrieved.
     * @param objectInstance the object instance.
     * @param &lt;T&gt; the object instance class.
     * @return the concrete class of a field
     */
    public &lt;T&gt; Class&lt;?&gt; getFieldClass(final Field field, final T objectInstance) {
<span class="fc" id="L420">        return getConcreteClass(field, reflectionUtils.getFieldValue(objectInstance, field));</span>
    }

    /**
     * Returns the concrete class of a field.
     * @param field the field for which the concrete class has to be retrieved.
     * @param fieldValue the field value.
     * @return the concrete class of a field
     */
    public Class&lt;?&gt; getConcreteClass(final Field field, final Object fieldValue) {
<span class="fc" id="L430">        final String cacheKey = &quot;ConcreteFieldClass-&quot; + field.getName() + &quot;-&quot; + field.getDeclaringClass();</span>
<span class="fc" id="L431">        return CACHE_MANAGER.getFromCache(cacheKey, Class.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L432">            Class&lt;?&gt; concreteType = field.getType();</span>
<span class="fc" id="L433">            boolean isFieldValueNull = isNull(fieldValue);</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (field.getType().isInterface()) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">                concreteType = isFieldValueNull ? Object.class : fieldValue.getClass();</span>
            }
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (!isFieldValueNull) {</span>
<span class="fc" id="L438">                CACHE_MANAGER.cacheObject(cacheKey, concreteType);</span>
            }
<span class="fc" id="L440">            return concreteType;</span>
        });
    }

    /**
     * Checks if the destination class has accessible constructor.
     * @param targetClass the destination object class
     * @param &lt;K&gt; the target object type
     * @return true if the target class uses the builder pattern
     */
    public &lt;K&gt; boolean hasAccessibleConstructors(final Class&lt;K&gt; targetClass) {
<span class="fc" id="L451">        final String cacheKey = &quot;HasAccessibleConstructors-&quot; + targetClass.getName();</span>
<span class="fc" id="L452">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L453">            final boolean res = stream(targetClass.getDeclaredConstructors()).anyMatch(constructor -&gt; isPublic(constructor.getModifiers()));</span>
<span class="fc" id="L454">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L455">            return res;</span>
        });
    }

    /**
     * Retrieves all classes defined into the given one.
     * @param clazz class where we search for a nested class
     * @return all classes defined into the given one
     */
    public Class[] getDeclaredClasses(final Class&lt;?&gt; clazz) {
<span class="fc" id="L465">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L466">        String cacheKey = &quot;DeclaredClasses-&quot; + clazz.getName();</span>
<span class="fc" id="L467">        return CACHE_MANAGER.getFromCache(cacheKey, Class[].class).orElseGet(() -&gt; {</span>
<span class="fc" id="L468">            Class[] declaredClasses = clazz.getDeclaredClasses();</span>
<span class="fc" id="L469">            CACHE_MANAGER.cacheObject(cacheKey, declaredClasses);</span>
<span class="fc" id="L470">            return declaredClasses;</span>
        });
    }

    /**
     * Returns the builder class.
     * @param targetClass the class where the builder should be searched
     * @return the Builder class if available.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Optional&lt;Class&lt;?&gt;&gt; getBuilderClass(final Class&lt;?&gt; targetClass) {
<span class="fc" id="L481">        String cacheKey = &quot;BuilderClass-&quot; + targetClass.getName();</span>
<span class="fc" id="L482">        return CACHE_MANAGER.getFromCache(cacheKey, Optional.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L483">            Optional&lt;Class&gt; res = stream(getDeclaredClasses(targetClass))</span>
<span class="fc" id="L484">                    .filter(nestedClass -&gt; {</span>
<span class="fc" id="L485">                        boolean hasBuildMethod = true;</span>
                        try {
<span class="fc" id="L487">                            getBuildMethod(targetClass, nestedClass);</span>
<span class="fc" id="L488">                        } catch (MissingMethodException e) {</span>
<span class="fc" id="L489">                            hasBuildMethod = false;</span>
<span class="fc" id="L490">                        }</span>
<span class="fc" id="L491">                        return hasBuildMethod;</span>
                    })
<span class="fc" id="L493">                    .findAny();</span>
<span class="fc" id="L494">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L495">            return res;</span>
        });
    }

    /**
     * Get build method inside the Builder class.
     * @param parentClass the class containing the builder
     * @param builderClass the builder class (see Builder Pattern)
     * @return Builder build method if present
     */
    public Method getBuildMethod(final Class&lt;?&gt; parentClass, final Class&lt;?&gt; builderClass) {
<span class="fc" id="L506">        final String cacheKey = &quot;BuildMethod-&quot; + builderClass.getName();</span>
<span class="fc" id="L507">        return CACHE_MANAGER.getFromCache(cacheKey, Method.class).orElseGet(() -&gt; {</span>
            try {
<span class="fc" id="L509">                Method method = builderClass.getDeclaredMethod(BUILD_METHOD_NAME);</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                if (!method.getReturnType().equals(parentClass)) {</span>
<span class="fc" id="L511">                    throw new MissingMethodException(&quot;Invalid &quot; + BUILD_METHOD_NAME + &quot; method definition. It must returns a: &quot; + parentClass.getCanonicalName());</span>
                }
<span class="fc" id="L513">                method.setAccessible(true);</span>
<span class="fc" id="L514">                CACHE_MANAGER.cacheObject(cacheKey, method);</span>
<span class="fc" id="L515">                return method;</span>
<span class="fc" id="L516">            } catch (NoSuchMethodException e) {</span>
<span class="fc" id="L517">                throw new MissingMethodException(&quot;No Builder &quot; + BUILD_METHOD_NAME + &quot; method defined for class: &quot; + builderClass.getName() + &quot;.&quot;);</span>
            }
        });
    }

    /**
     * Creates an instance of the given class invoking the given constructor.
     * @param constructor the constructor to invoke.
     * @param constructorArgs the constructor args.
     * @param &lt;T&gt; the class object type.
     * @return the object instance.
     * @throws InstanceCreationException in case the object creation fails.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getInstance(final Constructor constructor, final Object... constructorArgs) {
        try {
<span class="nc" id="L533">            return (T) constructor.newInstance(constructorArgs);</span>
<span class="fc" id="L534">        } catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {</span>
<span class="fc" id="L535">           throw new InstanceCreationException(e.getMessage(), e);</span>
        }
    }

    /**
     * Retrieves the no args constructor.
     * @param clazz the class from which gets the all arg constructor.
     * @param &lt;K&gt; the object type
     * @return the no args constructor
     * @throws InvalidBeanException if no default constructor is available
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;K&gt; Supplier&lt;K&gt; getNoArgsConstructor(final Class&lt;K&gt; clazz) {
<span class="fc" id="L548">        final String cacheKey = &quot;NoArgsConstructor-&quot; + clazz.getName();</span>
<span class="fc" id="L549">        return CACHE_MANAGER.getFromCache(cacheKey, Supplier.class).orElseGet(() -&gt; {</span>
            try {
<span class="fc" id="L551">                MethodHandles.Lookup privateLookupIn = privateLookupIn(clazz, METHOD_HANDLES_LOOKUP);</span>
<span class="fc" id="L552">                MethodHandle mh = privateLookupIn.findConstructor(clazz, methodType(void.class));</span>
<span class="fc" id="L553">                Supplier&lt;K&gt; constructor = (Supplier&lt;K&gt;) metafactory(</span>
<span class="fc" id="L554">                        privateLookupIn, &quot;get&quot;, methodType(Supplier.class), mh.type().generic(), mh, mh.type()</span>
<span class="fc" id="L555">                ).getTarget().invokeExact();</span>
<span class="fc" id="L556">                CACHE_MANAGER.cacheObject(cacheKey, constructor);</span>
<span class="fc" id="L557">                return constructor;</span>
<span class="fc" id="L558">            } catch (Throwable e) {</span>
<span class="fc" id="L559">                throw new InvalidBeanException(&quot;No default constructors available for class: &quot; + clazz.getName());</span>
            }
        });
    }

    /**
     * Retrieves the all args constructor.
     * @param clazz the class from which gets the all arg constructor.
     * @param &lt;K&gt; the object type
     * @return the all args constructor
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;K&gt; Constructor&lt;K&gt; getAllArgsConstructor(final Class&lt;K&gt; clazz) {
<span class="fc" id="L572">        final String cacheKey = &quot;AllArgsConstructor-&quot; + clazz.getName();</span>
<span class="fc" id="L573">        return CACHE_MANAGER.getFromCache(cacheKey, Constructor.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L574">            Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span>
<span class="fc" id="L575">            final Constructor constructor = max(asList(declaredConstructors), comparing(Constructor::getParameterCount));</span>
<span class="fc" id="L576">            constructor.setAccessible(true);</span>
<span class="fc" id="L577">            CACHE_MANAGER.cacheObject(cacheKey, constructor);</span>
<span class="fc" id="L578">            return constructor;</span>
        });
    }

    /**
     * Gets all the constructor parameters.
     * @param constructor the constructor.
     * @return the constructor parameters
     */
    public Parameter[] getConstructorParameters(final Constructor constructor) {
<span class="fc" id="L588">        final String cacheKey = &quot;ConstructorParams-&quot; + constructor.getDeclaringClass().getName() + '-' + constructor.getParameterCount();</span>
<span class="fc" id="L589">        return CACHE_MANAGER.getFromCache(cacheKey, Parameter[].class).orElseGet(() -&gt; {</span>
<span class="fc" id="L590">            final Parameter[] parameters = constructor.getParameters();</span>
<span class="fc" id="L591">            CACHE_MANAGER.cacheObject(cacheKey, parameters);</span>
<span class="fc" id="L592">            return parameters;</span>
        });
    }

    /**
     * Checks that the class has a specific field.
     * @param target the class where the field should be
     * @param fieldName the field name to retrieve
     * @return true if the field is available, false otherwise
     */
    public boolean hasField(final Object target, final String fieldName) {
<span class="fc" id="L603">        final String cacheKey = &quot;ClassHasField-&quot; + target.getClass().getName() + '-' + fieldName;</span>
<span class="fc" id="L604">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L605">            boolean hasField = false;</span>
            try {
<span class="fc" id="L607">                target.getClass().getDeclaredField(fieldName);</span>
<span class="fc" id="L608">                hasField = true;</span>
<span class="fc" id="L609">            } catch (final NoSuchFieldException e) {</span>
<span class="fc" id="L610">                final Class&lt;?&gt; superclass = target.getClass().getSuperclass();</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                if (hasSuperclass(superclass)) {</span>
<span class="fc" id="L612">                    hasField = hasField(superclass, fieldName);</span>
                }
<span class="fc" id="L614">            }</span>
<span class="fc" id="L615">            CACHE_MANAGER.cacheObject(cacheKey, hasField);</span>
<span class="fc" id="L616">            return hasField;</span>
        });
    }

    /**
     * Checks if a class has setter methods.
     * @param clazz clazz the clazz containing the methods.
     * @return true if has at least one setter method, false otherwise
     */
    public boolean hasSetterMethods(final Class&lt;?&gt; clazz) {
<span class="fc" id="L626">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L627">        final String cacheKey = &quot;HasSetterMethods-&quot; + clazz.getName();</span>
<span class="fc" id="L628">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class)</span>
<span class="fc" id="L629">                .orElseGet(() -&gt; {</span>
<span class="fc" id="L630">                    final Boolean res = stream(getDeclaredMethods(clazz)).anyMatch(reflectionUtils::isSetter);</span>
<span class="fc" id="L631">                    CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L632">                    return res;</span>
                });
    }

    /**
     * Retrieves the declared methods for the given class.
     * @param clazz class from which gets the methods
     * @return the class declared methods.
     */
    private Method[] getDeclaredMethods(final Class&lt;?&gt; clazz) {
<span class="fc" id="L642">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L643">        final String cacheKey = &quot;DeclaredMethods-&quot; + clazz.getName();</span>
<span class="fc" id="L644">        return CACHE_MANAGER.getFromCache(cacheKey, Method[].class)</span>
<span class="fc" id="L645">                .orElseGet(() -&gt; {</span>
<span class="fc" id="L646">                    final Method[] res = clazz.getDeclaredMethods();</span>
<span class="fc" id="L647">                    CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L648">                    return res;</span>
                });
    }

    /**
     * Checks if a class has any final field.
     * @param clazz class from which gets the field
     * @return true if it has private final field, false otherwise.
     */
    public boolean hasFinalFields(final Class&lt;?&gt; clazz) {
<span class="fc" id="L658">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L659">        return hasFieldsMatchingCondition(clazz, IS_FINAL_AND_NOT_STATIC_FIELD, &quot;HasFinalNotStaticFields-&quot;);</span>
    }

    /**
     * Checks if a class has any public field.
     * @param clazz class from which gets the field
     * @return true if it has private final field, false otherwise.
     */
    private boolean hasNotFinalFields(final Class&lt;?&gt; clazz) {
<span class="fc" id="L668">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L669">        return hasFieldsMatchingCondition(clazz, IS_NOT_FINAL_AND_NOT_STATIC_FIELD, &quot;HasNotFinalNotStaticFields-&quot;);</span>
    }

    /**
     * Checks if a class has any field matching the given condition.
     * @param clazz class from which gets the field
     * @param filterPredicate the filter to apply
     * @param cacheKey the filter to apply
     * @return true if it has private final field, false otherwise.
     */
    private boolean hasFieldsMatchingCondition(final Class&lt;?&gt; clazz, final Predicate&lt;Field&gt; filterPredicate, final String cacheKey) {
<span class="fc" id="L680">        return CACHE_MANAGER.getFromCache(cacheKey + clazz.getName(), Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L681">            boolean res = stream(getDeclaredFields(clazz))</span>
                    //.parallel()
<span class="fc" id="L683">                    .anyMatch(filterPredicate);</span>
<span class="pc bpc" id="L684" title="1 of 6 branches missed.">            if (!res &amp;&amp; nonNull(clazz.getSuperclass()) &amp;&amp; !clazz.getSuperclass().equals(Object.class)) {</span>
<span class="fc" id="L685">                Class&lt;?&gt; superclass = clazz.getSuperclass();</span>
<span class="fc" id="L686">                res = hasFieldsMatchingCondition(superclass, filterPredicate, cacheKey);</span>
            }
<span class="fc" id="L688">            CACHE_MANAGER.cacheObject(cacheKey + clazz.getName(), res);</span>
<span class="fc" id="L689">            return res;</span>
        });
    }

    /**
     * Checks if any of the class constructor's parameters are not annotated with the given class.
     * @param constructor the constructor to check.
     * @param annotationClass the annotation class to retrieve
     * @return true if any of the parameter does not contains the annotation, false otherwise.
     */
    public boolean allParameterAnnotatedWith(final Constructor constructor, final Class&lt;? extends Annotation&gt; annotationClass) {
<span class="fc" id="L700">        final String cacheKey = &quot;AllParameterAnnotatedWith-&quot; + constructor.getDeclaringClass().getName() + '-' + annotationClass.getName();</span>
<span class="fc" id="L701">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L702">            final boolean notAllAnnotatedWith = stream(constructor.getParameters())</span>
<span class="fc" id="L703">                    .allMatch(parameter -&gt; nonNull(parameter.getAnnotation(annotationClass)));</span>
<span class="fc" id="L704">            CACHE_MANAGER.cacheObject(cacheKey, notAllAnnotatedWith);</span>
<span class="fc" id="L705">            return notAllAnnotatedWith;</span>
        });
    }

    /**
     * Checks if the constructor's parameters names are defined.
     * @param constructor the constructor to check.
     * @return true if some parameters names are not defined, false otherwise.
     */
    public boolean areParameterNamesAvailable(final Constructor constructor) {
<span class="fc" id="L715">        final String cacheKey = &quot;AreParameterNamesAvailable-&quot; + constructor.getDeclaringClass().getName();</span>
<span class="fc" id="L716">        return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L717">            final boolean res = stream(getConstructorParameters(constructor))</span>
<span class="fc" id="L718">                    .anyMatch(Parameter::isNamePresent);</span>
<span class="fc" id="L719">            CACHE_MANAGER.cacheObject(cacheKey, res);</span>
<span class="fc" id="L720">            return res;</span>
        });
    }

    /**
     * Returns the class type.
     * @param clazz the class to check
     * @return the class type {@link ClassType}
     */
    public ClassType getClassType(final Class&lt;?&gt; clazz) {
<span class="fc" id="L730">        final String cacheKey = &quot;ClassType-&quot; + clazz.getName();</span>
<span class="fc" id="L731">        return CACHE_MANAGER.getFromCache(cacheKey, ClassType.class).orElseGet(() -&gt; {</span>
            final ClassType classType;
<span class="fc" id="L733">            boolean hasFinalFields = hasFinalFields(clazz);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (!hasFinalFields) {</span>
<span class="fc" id="L735">                classType = MUTABLE;</span>
            } else {
<span class="fc" id="L737">                boolean hasNotFinalFields = hasNotFinalFields(clazz);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                if (hasNotFinalFields) {</span>
<span class="fc" id="L739">                    classType = MIXED;</span>
                } else {
<span class="fc" id="L741">                    classType = IMMUTABLE;</span>
                }
            }
<span class="fc" id="L744">            CACHE_MANAGER.cacheObject(cacheKey, classType);</span>
<span class="fc" id="L745">            return classType;</span>
        });
    }

    /**
     * Retrieves all the setters method for the given class.
     * @param clazz the clazz containing the methods.
     * @return all the class setter methods
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Method&gt; getSetterMethods(final Class&lt;?&gt; clazz) {
<span class="fc" id="L756">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L757">        final String cacheKey = &quot;SetterMethods-&quot; + clazz.getName();</span>
<span class="fc" id="L758">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L759">            final List&lt;Method&gt; setterMethods = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if (hasSuperclass(clazz.getSuperclass())) {</span>
<span class="fc" id="L761">                setterMethods.addAll(getSetterMethods(clazz.getSuperclass()));</span>
            }
<span class="fc" id="L763">            setterMethods.addAll(stream(getDeclaredMethods(clazz))</span>
<span class="fc" id="L764">                    .filter(reflectionUtils::isSetter)</span>
<span class="fc" id="L765">                    .collect(toList()));</span>
<span class="fc" id="L766">            CACHE_MANAGER.cacheObject(cacheKey, setterMethods);</span>
<span class="fc" id="L767">            return setterMethods;</span>
        });
    }

    /**
     * Retrieves all the setters method for the given class.
     * @param clazz the clazz containing the methods.
     * @return all the class setter methods
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Method&gt; getGetterMethods(final Class&lt;?&gt; clazz) {
<span class="fc" id="L778">        notNull(clazz, CLAZZ_CANNOT_BE_NULL);</span>
<span class="fc" id="L779">        final String cacheKey = &quot;GetterMethods-&quot; + clazz.getName();</span>
<span class="fc" id="L780">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L781">            final List&lt;Method&gt; setterMethods = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">            if (hasSuperclass(clazz.getSuperclass())) {</span>
<span class="fc" id="L783">                setterMethods.addAll(getGetterMethods(clazz.getSuperclass()));</span>
            }
<span class="fc" id="L785">            setterMethods.addAll(stream(getDeclaredMethods(clazz))</span>
<span class="fc" id="L786">                    .filter(reflectionUtils::isGetter)</span>
<span class="fc" id="L787">                    .collect(toList()));</span>
<span class="fc" id="L788">            CACHE_MANAGER.cacheObject(cacheKey, setterMethods);</span>
<span class="fc" id="L789">            return setterMethods;</span>
        });
    }

    /**
     * Gets the default value of a primitive type.
     * @param objectType the primitive object class
     * @return the default value of a primitive type
     */
    public Object getDefaultTypeValue(final Class&lt;?&gt; objectType) {
<span class="fc" id="L799">        final String cacheKey = &quot;DefaultTypeValue-&quot; + objectType.getName();</span>
<span class="fc" id="L800">        return CACHE_MANAGER.getFromCache(cacheKey, Object.class).orElseGet(() -&gt; {</span>
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">            final Object defaultValue = isPrimitiveType(objectType) ? defaultValue(objectType) : null;</span>
<span class="fc" id="L802">            CACHE_MANAGER.cacheObject(cacheKey, defaultValue);</span>
<span class="fc" id="L803">            return defaultValue;</span>
        });
    }

    /**
     * Returns all the not final fields.
     * @param clazz the class containing fields.
     * @param skipStatic if true the static fields are skipped.
     * @return a list containing all the not final fields.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;Field&gt; getNotFinalFields(final Class&lt;?&gt; clazz, final Boolean skipStatic) {
<span class="fc" id="L815">        final String cacheKey = &quot;NotFinalFields-&quot; + clazz.getName() + &quot;-&quot; + skipStatic;</span>
<span class="fc" id="L816">        return CACHE_MANAGER.getFromCache(cacheKey, List.class).orElseGet(() -&gt; {</span>
<span class="fc" id="L817">            List&lt;Field&gt; notFinalFields = getDeclaredFields(clazz, skipStatic)</span>
<span class="fc" id="L818">                    .stream()</span>
<span class="fc" id="L819">                    .filter(IS_NOT_FINAL_FIELD).collect(toList());</span>
<span class="fc" id="L820">            CACHE_MANAGER.cacheObject(cacheKey, notFinalFields);</span>
<span class="fc" id="L821">            return notFinalFields;</span>
        });
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
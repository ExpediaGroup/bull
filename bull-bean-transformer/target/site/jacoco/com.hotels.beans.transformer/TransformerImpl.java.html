<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransformerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BULL - Bean Transformer</a> &gt; <a href="index.source.html" class="el_package">com.hotels.beans.transformer</a> &gt; <span class="el_source">TransformerImpl.java</span></div><h1>TransformerImpl.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2019-2020 Expedia, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hotels.beans.transformer;

import static java.util.Arrays.stream;
import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static java.util.stream.Collectors.joining;
import static java.util.stream.IntStream.range;

import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

import static com.hotels.beans.populator.PopulatorFactory.getPopulator;
import static com.hotels.transformer.base.Defaults.defaultValue;
import static com.hotels.transformer.constant.ClassType.MIXED;
import static com.hotels.transformer.constant.ClassType.MUTABLE;
import static com.hotels.transformer.constant.Punctuation.COMMA;
import static com.hotels.transformer.constant.Punctuation.DOT;
import static com.hotels.transformer.constant.Punctuation.LPAREN;
import static com.hotels.transformer.constant.Punctuation.RPAREN;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Parameter;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;

import com.hotels.transformer.annotation.ConstructorArg;
import com.hotels.transformer.constant.ClassType;
import com.hotels.transformer.error.InvalidBeanException;
import com.hotels.transformer.error.MissingFieldException;
import com.hotels.transformer.model.FieldTransformer;

/**
 * Utility methods for populating Mutable, Immutable and Hybrid JavaBeans properties via reflection.
 * The implementations are provided by BeanUtils.
 */
<span class="fc" id="L56">public class TransformerImpl extends AbstractBeanTransformer {</span>
    /**
     * {@inheritDoc}
     */
    @Override
    protected final &lt;T, K&gt; K transform(final T sourceObj, final Class&lt;? extends K&gt; targetClass, final String breadcrumb) {
        final K k;
<span class="fc" id="L63">        final Optional&lt;Class&lt;?&gt;&gt; builderClass = getBuilderClass(targetClass);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (builderClass.isPresent()) {</span>
<span class="fc" id="L65">            k = injectThroughBuilder(sourceObj, targetClass, builderClass.get(), breadcrumb);</span>
        } else {
<span class="fc" id="L67">            k = injectValues(sourceObj, targetClass, breadcrumb);</span>
        }
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (settings.isValidationEnabled()) {</span>
<span class="fc" id="L70">            validator.validate(k);</span>
        }
<span class="fc" id="L72">        return k;</span>
    }

    /**
     * Gets the Java Bean Builder class (if any).
     * @param targetClass the destination object class
     * @param &lt;K&gt; the target object type
     * @return the Builder class
     */
    private &lt;K&gt; Optional&lt;Class&lt;?&gt;&gt; getBuilderClass(final Class&lt;? extends K&gt; targetClass) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">        return !settings.isCustomBuilderTransformationEnabled() ? empty() : classUtils.getBuilderClass(targetClass);</span>
    }

    /**
     * Inject all properties value from an object to a new one using the class builder.
     * @param sourceObj the source object
     * @param targetClass the destination object class
     * @param builderClass the builder class inside the Bean
     * @param breadcrumb the full path of the current field starting from his ancestor
     * @param &lt;T&gt; the Source object type
     * @param &lt;K&gt; the target object type
     * @return a copy of the source object into the destination object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T, K&gt; K injectThroughBuilder(final T sourceObj, final Class&lt;? extends K&gt; targetClass, final Class&lt;?&gt; builderClass, final String breadcrumb) {
<span class="fc" id="L97">        return (K) reflectionUtils.invokeMethod(classUtils.getBuildMethod(targetClass, builderClass), injectValues(sourceObj, builderClass, breadcrumb));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected final &lt;T, K&gt; void transform(final T sourceObj, final K targetObject, final String breadcrumb) {
<span class="fc" id="L105">        injectAllFields(sourceObj, targetObject, breadcrumb);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (settings.isValidationEnabled()) {</span>
<span class="fc" id="L107">            validator.validate(targetObject);</span>
        }
<span class="fc" id="L109">    }</span>

    /**
     * Inject all properties value from an object to a new one.
     * @param sourceObj the source object
     * @param targetClass the destination object class
     * @param breadcrumb the full path of the current field starting from his ancestor
     * @param &lt;T&gt; the Source object type
     * @param &lt;K&gt; the target object type
     * @return a copy of the source object into the destination object
     */
    private &lt;T, K&gt; K injectValues(final T sourceObj, final Class&lt;? extends K&gt; targetClass, final String breadcrumb) {
        final K k;
<span class="fc" id="L122">        final ClassType classType = classUtils.getClassType(targetClass);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (classType.is(MUTABLE)) {</span>
            try {
<span class="fc" id="L125">                k = classUtils.getNoArgsConstructor(targetClass).get();</span>
<span class="fc" id="L126">                injectAllFields(sourceObj, k, breadcrumb);</span>
<span class="fc" id="L127">            } catch (Exception e) {</span>
<span class="fc" id="L128">                throw new InvalidBeanException(e.getMessage(), e);</span>
<span class="fc" id="L129">            }</span>
        } else {
<span class="fc" id="L131">            k = injectValues(sourceObj, targetClass, classUtils.getAllArgsConstructor(targetClass), breadcrumb, false);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (classType.is(MIXED)) {</span>
<span class="fc" id="L133">                injectNotFinalFields(sourceObj, k, breadcrumb);</span>
            }
        }
<span class="fc" id="L136">        return k;</span>
    }

    /**
     * Inject the values through the all args constructor.
     * @param sourceObj   sourceObj the source object
     * @param targetClass the destination object class
     * @param constructor the all args constructor
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param forceConstructorInjection if true it forces the injection trough constructor
     * @param &lt;T&gt;         the sourceObj object type
     * @param &lt;K&gt;         the target object type
     * @return a copy of the source object into the destination object
     * @throws InvalidBeanException {@link InvalidBeanException} if the target object is not compliant with the requirements
     */
    private &lt;T, K&gt; K injectValues(final T sourceObj, final Class&lt;K&gt; targetClass, final Constructor constructor, final String breadcrumb, final boolean forceConstructorInjection) {
        final Object[] constructorArgs;
<span class="fc bfc" id="L153" title="All 4 branches covered.">        if (forceConstructorInjection || canBeInjectedByConstructorParams(constructor)) {</span>
<span class="fc" id="L154">            constructorArgs = getConstructorArgsValues(sourceObj, targetClass, constructor, breadcrumb);</span>
        } else {
<span class="fc" id="L156">            constructorArgs = getConstructorValuesFromFields(sourceObj, targetClass, breadcrumb);</span>
        }
        try {
<span class="fc" id="L159">            return classUtils.getInstance(constructor, constructorArgs);</span>
<span class="fc" id="L160">        } catch (final Exception e) {</span>
<span class="fc" id="L161">            return handleInjectionException(sourceObj, targetClass, constructor, breadcrumb, constructorArgs, forceConstructorInjection, e);</span>
        }
    }

    /**
     * Handles the exception thrown by method: {@code injectValues}.
     * In case an exception is raised due to missing parameter names it tries to inject through the constructor anyway.
     * @param sourceObj   sourceObj the source object
     * @param targetClass the destination object class
     * @param constructor the all args constructor
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param constructorArgs the constructor arguments
     * @param forceConstructorInjection if true it forces the injection trough constructor
     * @param e the raised exception
     * @param &lt;T&gt;         the sourceObj object type
     * @param &lt;K&gt;         the target object type
     * @return a copy of the source object into the destination object
     * @throws InvalidBeanException {@link InvalidBeanException} if the target object is not compliant with the requirements
     */
    protected &lt;T, K&gt; K handleInjectionException(final T sourceObj, final Class&lt;K&gt; targetClass, final Constructor constructor, final String breadcrumb,
        final Object[] constructorArgs, final boolean forceConstructorInjection, final Exception e) {
        String errorMsg;
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (!classUtils.areParameterNamesAvailable(constructor)) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (!forceConstructorInjection) {</span>
<span class="fc" id="L185">                return injectValues(sourceObj, targetClass, constructor, breadcrumb, true);</span>
            } else {
<span class="fc" id="L187">                errorMsg = &quot;Constructor's parameters name have been removed from the compiled code. &quot;</span>
<span class="fc" id="L188">                        + &quot;This caused a problems during the: &quot; + targetClass.getSimpleName() + &quot; injection. &quot;</span>
                        + &quot;Consider to use: @ConstructorArg annotation: https://github.com/HotelsDotCom/bull#different-field-names-defining-constructor-args &quot;
                        + &quot;or add the property: &lt;parameters&gt;true&lt;/parameters&gt; to your maven-compiler configuration&quot;;
            }
        } else {
<span class="fc" id="L193">            errorMsg = &quot;Constructor invoked with wrong arguments. Expected: &quot; + constructor + &quot;; Found: &quot;</span>
<span class="fc" id="L194">                    + getFormattedConstructorArgs(targetClass, constructorArgs)</span>
<span class="fc" id="L195">                    + &quot;. Double check that each &quot; + targetClass.getSimpleName() + &quot;'s field have the same type and name than the source object: &quot;</span>
<span class="fc" id="L196">                    + sourceObj.getClass().getName() + &quot; otherwise specify a transformer configuration. Error message: &quot; + e.getMessage();</span>
        }
<span class="fc" id="L198">        throw new InvalidBeanException(errorMsg, e);</span>
    }

    /**
     * Creates a string containing the arguments used to invoke the given class constructor.
     * @param targetClass the class containing the constructor
     * @param constructorArgs the passed arguments
     * @param &lt;K&gt; he target object type
     * @return the formatted constructor arguments
     */
    private &lt;K&gt; String getFormattedConstructorArgs(final Class&lt;K&gt; targetClass, final Object[] constructorArgs) {
<span class="fc" id="L209">        return stream(constructorArgs)</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                .map(arg -&gt; isNull(arg) ? &quot;null&quot; : arg.getClass().getName())</span>
<span class="fc" id="L211">                .collect(joining(COMMA.getSymbol(), targetClass.getName() + LPAREN.getSymbol(), RPAREN.getSymbol()));</span>
    }

    /**
     * Checks if the source class field names can be retrieved from the constructor parameters.
     * @param constructor the all args constructor
     * @return true if the parameter names are defined or the parameters are annotated with: {@link ConstructorArg}
     */
    protected boolean canBeInjectedByConstructorParams(final Constructor constructor) {
<span class="fc" id="L220">        final String cacheKey = &quot;CanBeInjectedByConstructorParams-&quot; + constructor.getDeclaringClass().getName();</span>
<span class="fc" id="L221">        return cacheManager.getFromCache(cacheKey, Boolean.class).orElseGet(() -&gt; {</span>
<span class="pc bpc" id="L222" title="3 of 4 branches missed.">            final boolean res = classUtils.areParameterNamesAvailable(constructor) || classUtils.allParameterAnnotatedWith(constructor, ConstructorArg.class);</span>
<span class="fc" id="L223">            cacheManager.cacheObject(cacheKey, res);</span>
<span class="fc" id="L224">            return res;</span>
        });
    }

    /**
     * Retrieves all the constructor argument values.
     * This methods uses the {@link ConstructorArg} to retrieve the argument values
     * @param sourceObj   sourceObj the source object
     * @param targetClass the destination object class
     * @param constructor the all args constructor
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;         the sourceObj object type
     * @param &lt;K&gt;         the target object type
     * @return a list containing the values for the destination constructor.
     * @throws InvalidBeanException {@link InvalidBeanException} if there is an error while retrieving the constructor args parameter
     */
    protected &lt;T, K&gt; Object[] getConstructorArgsValues(final T sourceObj, final Class&lt;K&gt; targetClass, final Constructor constructor, final String breadcrumb) {
<span class="fc" id="L241">        final Parameter[] constructorParameters = classUtils.getConstructorParameters(constructor);</span>
<span class="fc" id="L242">        final Object[] constructorArgsValues = new Object[constructorParameters.length];</span>
<span class="fc" id="L243">        range(0, constructorParameters.length)</span>
                //.parallel()
<span class="fc" id="L245">                .forEach(i -&gt; {</span>
<span class="fc" id="L246">                    String destFieldName = getDestFieldName(constructorParameters[i], targetClass.getName());</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                    if (isNull(destFieldName)) {</span>
<span class="fc" id="L248">                        constructorArgsValues[i] = classUtils.getDefaultTypeValue(constructorParameters[i].getType());</span>
                    } else {
<span class="fc" id="L250">                        String sourceFieldName = getSourceFieldName(destFieldName);</span>
<span class="fc" id="L251">                        constructorArgsValues[i] =</span>
<span class="fc" id="L252">                                getFieldValue(sourceObj, sourceFieldName, targetClass, reflectionUtils.getDeclaredField(destFieldName, targetClass), breadcrumb);</span>
                    }
<span class="fc" id="L254">                });</span>
<span class="fc" id="L255">        return constructorArgsValues;</span>
    }

    /**
     * Checks if a field has to be transformed or not.
     * @param breadcrumb the field path
     * @return true if the transformation has to be applied on this field, false in it has to be skipped.
     */
    private boolean doSkipTransformation(final String breadcrumb) {
<span class="fc" id="L264">        return settings.getFieldsToSkip().contains(breadcrumb);</span>
    }

    /**
     * Returns the field name in the source object.
     * @param field the field that has to be set.
     * @return the source field name.
     */
    private String getSourceFieldName(final Field field) {
<span class="fc" id="L273">        return getSourceFieldName(field.getName());</span>
    }

    /**
     * Returns the field name in the source object.
     * @param fieldName the field name that has to be set.
     * @return the source field name.
     */
    private String getSourceFieldName(final String fieldName) {
<span class="fc" id="L282">        return ofNullable(settings.getFieldsNameMapping().get(fieldName)).orElse(fieldName);</span>
    }

    /**
     * Returns the field name in the destination object.
     * @param constructorParameter the constructor parameter.
     * @param declaringClassName the class containing the constructor.
     * @return the source field name.
     */
    private String getDestFieldName(final Parameter constructorParameter, final String declaringClassName) {
<span class="fc" id="L292">        String cacheKey = &quot;DestFieldName-&quot; + declaringClassName + &quot;-&quot; + constructorParameter.getName();</span>
<span class="fc" id="L293">        return cacheManager.getFromCache(cacheKey, String.class)</span>
<span class="fc" id="L294">                .orElseGet(() -&gt; {</span>
                    String destFieldName;
<span class="fc bfc" id="L296" title="All 2 branches covered.">                    if (constructorParameter.isNamePresent()) {</span>
<span class="fc" id="L297">                        destFieldName = constructorParameter.getName();</span>
                    } else {
<span class="fc" id="L299">                        destFieldName = ofNullable(reflectionUtils.getParameterAnnotation(constructorParameter, ConstructorArg.class, declaringClassName))</span>
<span class="fc" id="L300">                                .map(ConstructorArg::value)</span>
<span class="fc" id="L301">                                .orElse(null);</span>
                    }
<span class="fc" id="L303">                    cacheManager.cacheObject(cacheKey, destFieldName);</span>
<span class="fc" id="L304">                    return destFieldName;</span>
                });
    }

    /**
     * Retrieves all the constructor argument values.
     * This methods retrieves the values from the declared class field into the target object.
     * @param sourceObj   sourceObj the source object
     * @param targetClass the destination object class
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;         the sourceObj object type
     * @param &lt;K&gt;         the target object type
     * @return a list containing the values for the destination constructor.
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; Object[] getConstructorValuesFromFields(final T sourceObj, final Class&lt;K&gt; targetClass, final String breadcrumb) {
<span class="fc" id="L320">        final List&lt;Field&gt; declaredFields = classUtils.getDeclaredFields(targetClass, true);</span>
<span class="fc" id="L321">        return declaredFields.stream()</span>
<span class="fc" id="L322">                .map(field -&gt; getFieldValue(sourceObj, targetClass, field, breadcrumb))</span>
<span class="fc" id="L323">                .toArray(Object[]::new);</span>
    }

    /**
     * Injects the values for all class fields.
     * @param sourceObj sourceObj the source object
     * @param targetObject the destination object instance
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;  the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; void injectAllFields(final T sourceObj, final K targetObject, final String breadcrumb) {
<span class="fc" id="L336">        final Class&lt;?&gt; targetObjectClass = targetObject.getClass();</span>
<span class="fc" id="L337">        injectFields(classUtils.getDeclaredFields(targetObjectClass, true), sourceObj, targetObject, targetObjectClass, breadcrumb);</span>
<span class="fc" id="L338">    }</span>

    /**
     * Creates a {@link Consumer} that sets the field value in the given class.
     * @param sourceObj sourceObj the source object
     * @param targetObject the destination object instance
     * @param targetObjectClass  the target object class
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;  the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @return a {@link Consumer} that sets the field value in the target object
     */
    private &lt;T, K&gt; Consumer&lt;Field&gt; setFieldValue(final T sourceObj, final K targetObject, final Class&lt;?&gt; targetObjectClass, final String breadcrumb) {
<span class="fc" id="L351">        return field -&gt; reflectionUtils.setFieldValue(targetObject, field, getFieldValue(sourceObj, targetObjectClass, field, breadcrumb));</span>
    }

    /**
     * Injects the values for all the not final fields.
     * @param sourceObj sourceObj the source object
     * @param targetObject the destination object instance
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;  the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; void injectNotFinalFields(final T sourceObj, final K targetObject, final String breadcrumb) {
<span class="fc" id="L364">        final Class&lt;?&gt; targetObjectClass = targetObject.getClass();</span>
<span class="fc" id="L365">        injectFields(classUtils.getNotFinalFields(targetObjectClass, true), sourceObj, targetObject, targetObjectClass, breadcrumb);</span>
<span class="fc" id="L366">    }</span>

    /**
     * Injects the values for given final fields.
     * @param fieldList the list of field to inject
     * @param sourceObj sourceObj the source object
     * @param targetObject the destination object instance
     * @param targetObjectClass the destination object class
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt;  the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; void injectFields(final List&lt;Field&gt; fieldList, final T sourceObj, final K targetObject, final Class&lt;?&gt; targetObjectClass, final String breadcrumb) {
<span class="fc" id="L380">        fieldList</span>
                //.parallelStream()
<span class="fc" id="L382">                .forEach(setFieldValue(sourceObj, targetObject, targetObjectClass, breadcrumb));</span>
<span class="fc" id="L383">    }</span>

    /**
     * Retrieves the value of a field. In case it is not a primitive type it recursively inject the values inside the object.
     * @param sourceObj sourceObj the source object
     * @param targetClass the destination object class
     * @param field The field for which the value has to be retrieved
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt; the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @return the field value
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; Object getFieldValue(final T sourceObj, final Class&lt;K&gt; targetClass, final Field field, final String breadcrumb) {
<span class="fc" id="L397">        String sourceFieldName = getSourceFieldName(field);</span>
<span class="fc" id="L398">        return getFieldValue(sourceObj, sourceFieldName, targetClass, field, breadcrumb);</span>
    }

    /**
     * Retrieves the value of a field. In case it is not a primitive type it recursively inject the values inside the object.
     * @param sourceObj sourceObj the source object
     * @param sourceFieldName sourceFieldName the field name in the source object (if different from the target one)
     * @param targetClass the destination object class
     * @param field The field for which the value has to be retrieved
     * @param breadcrumb  the full path of the current field starting from his ancestor
     * @param &lt;T&gt; the sourceObj object type
     * @param &lt;K&gt; the target object type
     * @return the field value
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    private &lt;T, K&gt; Object getFieldValue(final T sourceObj, final String sourceFieldName, final Class&lt;K&gt; targetClass, final Field field, final String breadcrumb) {
<span class="fc" id="L414">        String fieldBreadcrumb = evalBreadcrumb(field.getName(), breadcrumb);</span>
<span class="fc" id="L415">        Class&lt;?&gt; fieldType = field.getType();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (doSkipTransformation(fieldBreadcrumb)) {</span>
<span class="fc" id="L417">            return defaultValue(fieldType);</span>
        }
<span class="fc" id="L419">        boolean primitiveType = classUtils.isPrimitiveType(fieldType);</span>
<span class="fc" id="L420">        FieldTransformer transformerFunction = getTransformerFunction(field, fieldBreadcrumb);</span>
<span class="fc" id="L421">        boolean isTransformerFunctionDefined = nonNull(transformerFunction);</span>
<span class="fc" id="L422">        Object fieldValue = getSourceFieldValue(sourceObj, sourceFieldName, field, isTransformerFunctionDefined);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (nonNull(fieldValue)) {</span>
            // is not a primitive type or an optional &amp;&amp; there are no transformer function
            // defined it recursively evaluate the value
<span class="fc bfc" id="L426" title="All 4 branches covered.">            boolean notPrimitiveAndNotSpecialType = !primitiveType &amp;&amp; !classUtils.isSpecialType(fieldType);</span>
<span class="fc bfc" id="L427" title="All 4 branches covered.">            if (!isTransformerFunctionDefined</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                    &amp;&amp; (notPrimitiveAndNotSpecialType || Optional.class.isAssignableFrom(fieldValue.getClass()))) {</span>
<span class="fc" id="L429">                fieldValue = getFieldValue(targetClass, field, fieldValue, fieldBreadcrumb);</span>
            }
<span class="fc bfc" id="L431" title="All 6 branches covered.">        } else if (primitiveType &amp;&amp; settings.isDefaultValueForMissingPrimitiveField() &amp;&amp; !isTransformerFunctionDefined) {</span>
<span class="fc" id="L432">            fieldValue = defaultValue(fieldType); // assign the default value</span>
        }
<span class="fc" id="L434">        fieldValue = getTransformedValue(transformerFunction, fieldValue, sourceObj.getClass(), sourceFieldName, field, primitiveType, fieldBreadcrumb);</span>
<span class="fc" id="L435">        return fieldValue;</span>
    }

    /**
     * Applies all the transformer function associated to the field and returns the results.
     * If the field type is different and they are primitive a conversion function is automatically applied.
     * @param transformerFunction the transformer function defined for the current field
     * @param fieldValue the field value
     * @param sourceObjectClass the source object class
     * @param sourceFieldName the source field name
     * @param field the field on which the transformation should be applied
     * @param isDestinationFieldPrimitiveType indicates if the destination field type is primitive or not
     * @param breadcrumb The full field path on which the transformation should be applied
     * @return the transformer function.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Object getTransformedValue(final FieldTransformer transformerFunction, final Object fieldValue,
        final Class&lt;?&gt; sourceObjectClass, final String sourceFieldName, final Field field,
        final boolean isDestinationFieldPrimitiveType, final String breadcrumb) {
<span class="fc" id="L454">        Object transformedValue = fieldValue;</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">        if (settings.isPrimitiveTypeConversionEnabled() &amp;&amp; isDestinationFieldPrimitiveType) {</span>
<span class="fc" id="L456">            transformedValue = applyPrimitiveTypeConversion(sourceObjectClass, sourceFieldName, field, breadcrumb, transformedValue);</span>
        }
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (transformerFunction != null) {</span>
<span class="fc" id="L459">            transformedValue = transformerFunction.getTransformedObject(transformedValue);</span>
        }
<span class="fc" id="L461">        return transformedValue;</span>
    }

    /**
     * Build the current field breadcrumb.
     * @param fieldName the field name
     * @param breadcrumb the existing breadcrumb
     * @return the updated breadcrumb
     */
    private String evalBreadcrumb(final String fieldName, final String breadcrumb) {
<span class="fc bfc" id="L471" title="All 2 branches covered.">        return (isNotEmpty(breadcrumb) ? breadcrumb + DOT.getSymbol() : EMPTY) + fieldName;</span>
    }

    /**
     * Gets the source field value. If a field transformer function is defined and the field does not exists in the source object it raises an exception.
     * @param sourceObj sourceObj the source object
     * @param sourceFieldName sourceFieldName the field name in the source object (if different from the target one)
     * @param field the field for which the value has to be retrieved
     * @param isFieldTransformerDefined indicates if a transformer function is implemented for this field
     * @param &lt;T&gt; the sourceObj object type
     * @return the source field value
     */
    private &lt;T&gt; Object getSourceFieldValue(final T sourceObj, final String sourceFieldName, final Field field, final boolean isFieldTransformerDefined) {
<span class="fc" id="L484">        Object fieldValue = null;</span>
        try {
<span class="fc" id="L486">            fieldValue = reflectionUtils.getFieldValue(sourceObj, sourceFieldName, field.getType());</span>
<span class="fc" id="L487">        } catch (MissingFieldException e) {</span>
            // in case the source field is a primitive type and the destination one is composite, the source field value is returned without going in deep
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (classUtils.isPrimitiveType(sourceObj.getClass())) {</span>
<span class="fc" id="L490">                fieldValue = sourceObj;</span>
<span class="fc bfc" id="L491" title="All 4 branches covered.">            } else if (!isFieldTransformerDefined &amp;&amp; !settings.isSetDefaultValueForMissingField()) {</span>
<span class="fc" id="L492">                throw e;</span>
            }
<span class="fc" id="L494">        } catch (Exception e) {</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            if (!isFieldTransformerDefined) {</span>
<span class="fc" id="L496">                throw e;</span>
            }
<span class="fc" id="L498">        }</span>
<span class="fc" id="L499">        return fieldValue;</span>
    }

    /**
     * Gets the source field type.
     * @param sourceObjectClass the source object class
     * @param sourceFieldName sourceFieldName the field name in the source object (if different from the target one)
     * @return the source field type
     */
    private Class&lt;?&gt; getSourceFieldType(final Class&lt;?&gt; sourceObjectClass, final String sourceFieldName) {
<span class="fc" id="L509">        String cacheKey = &quot;SourceFieldType-&quot; + sourceObjectClass.getName() + &quot;-&quot; + sourceFieldName;</span>
<span class="fc" id="L510">        return cacheManager.getFromCache(cacheKey, Class.class)</span>
<span class="fc" id="L511">                .orElseGet(() -&gt; {</span>
<span class="fc" id="L512">                    Class&lt;?&gt; classType = null;</span>
                    try {
<span class="fc" id="L514">                        classType = reflectionUtils.getDeclaredFieldType(sourceFieldName, sourceObjectClass);</span>
<span class="fc" id="L515">                    } catch (MissingFieldException e) {</span>
                        // in case the source field is a primitive type and the destination one is composite,
                        // the source field type is returned without going in deep
<span class="fc bfc" id="L518" title="All 2 branches covered.">                        if (classUtils.isPrimitiveType(sourceObjectClass)) {</span>
<span class="fc" id="L519">                            classType = sourceObjectClass;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                        } else if (!settings.isSetDefaultValueForMissingField()) {</span>
<span class="fc" id="L521">                            throw e;</span>
                        }
<span class="fc" id="L523">                    }</span>
<span class="fc" id="L524">                    cacheManager.cacheObject(cacheKey, classType);</span>
<span class="fc" id="L525">                    return classType;</span>
                });
    }

    /**
     * Retrieves the transformer function.
     * @param field The field on which the transformation should be applied.
     * @param breadcrumb The full field path on which the transformation should be applied.
     * @return the transformer function.
     */
    private FieldTransformer getTransformerFunction(final Field field, final String breadcrumb) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">        return settings.getFieldsTransformers().get(settings.isFlatFieldNameTransformation() ? field.getName() : breadcrumb);</span>
    }

    /**
     * Retrieves the transformer functions. If the field type is different and they are primitive
     * a conversion function is automatically added.
     * @param sourceObjectClass the source object class
     * @param sourceFieldName the source field name
     * @param field the field on which the transformation should be applied
     * @param fieldTransformerKey the field transformation key
     * @param fieldValue the field value
     * @return the transformer function.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Object applyPrimitiveTypeConversion(final Class&lt;?&gt; sourceObjectClass, final String sourceFieldName,
        final Field field, final String fieldTransformerKey, final Object fieldValue) {
<span class="fc" id="L552">        Object transformedValue = fieldValue;</span>
<span class="fc" id="L553">        FieldTransformer primitiveTypeTransformer = getPrimitiveTypeTransformer(sourceObjectClass, sourceFieldName, field, fieldTransformerKey);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (nonNull(primitiveTypeTransformer)) {</span>
<span class="fc" id="L555">            transformedValue = primitiveTypeTransformer.getTransformedObject(fieldValue);</span>
        }
<span class="fc" id="L557">        return transformedValue;</span>
    }

    /**
     * Verifies if a default type transformer function is required and in case returns it.
     * @param sourceObjectClass the source object class
     * @param sourceFieldName the source field name
     * @param field the field on which the transformation should be applied.
     * @param fieldTransformerKey the field name or the full path to the field to which assign the transformer
     * @return the default type transformer function
     */
    private FieldTransformer getPrimitiveTypeTransformer(final Class&lt;?&gt; sourceObjectClass, final String sourceFieldName,
        final Field field, final String fieldTransformerKey) {
<span class="fc" id="L570">        String cacheKey = TRANSFORMER_FUNCTION_CACHE_PREFIX + &quot;-&quot; + field.getDeclaringClass().getName() + &quot;-&quot; + fieldTransformerKey + &quot;-&quot; + field.getName();</span>
<span class="fc" id="L571">        return cacheManager.getFromCache(cacheKey, FieldTransformer.class)</span>
<span class="fc" id="L572">                .orElseGet(() -&gt; {</span>
<span class="fc" id="L573">                    FieldTransformer primitiveTypeTransformer = null;</span>
<span class="fc" id="L574">                    Class&lt;?&gt; sourceFieldType = getSourceFieldType(sourceObjectClass, sourceFieldName);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                    if (nonNull(sourceFieldType)) {</span>
<span class="fc" id="L576">                        primitiveTypeTransformer = conversionAnalyzer.getConversionFunction(sourceFieldType, field.getType())</span>
<span class="fc" id="L577">                                .map(conversionFunction -&gt; new FieldTransformer&lt;&gt;(fieldTransformerKey, conversionFunction))</span>
<span class="fc" id="L578">                                .orElse(null);</span>
                    }
<span class="fc" id="L580">                    cacheManager.cacheObject(cacheKey, primitiveTypeTransformer);</span>
<span class="fc" id="L581">                    return primitiveTypeTransformer;</span>
                });
    }

    /**
     * Retrieves the value of a field.
     * @param targetClass the destination object class
     * @param field The field for which the value has to be retrieved
     * @param fieldValue The current object value.
     * @param breadcrumb The full field path on which the transformation should be applied
     * @param &lt;K&gt; the target object type
     * @return the field value
     * @throws InvalidBeanException {@link InvalidBeanException} if an error occurs while retrieving the value
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;K&gt; Object getFieldValue(final Class&lt;K&gt; targetClass, final Field field, final Object fieldValue, final String breadcrumb) {
<span class="fc" id="L597">        return getPopulator(field.getType(), fieldValue.getClass(), this)</span>
<span class="fc" id="L598">                .map(populator -&gt; populator.getPopulatedObject(targetClass, field.getName(), fieldValue))</span>
<span class="fc" id="L599">                .orElseGet(() -&gt;</span>
                        // recursively inject object
<span class="fc" id="L601">                        transform(fieldValue, classUtils.getConcreteClass(field, fieldValue), breadcrumb)</span>
                );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>